name: Build/Publish Docker Images and, optionally, Singularity Images on CVMFS

on:
  workflow_call:
    inputs:
      image_registry:
        description: |
          The target image's container registry hostname (no namespace).
          Examples: ghcr.io, docker.io, harbor.icecube.aq
        type: string
        default: ghcr.io
      image_namespace:
        description: |
          The target image's namespace or project path in the registry (can include slashes).
          Examples: foo, foo/bar, myproject
        type: string
        required: true
      image_name:
        description: |
          The target image's name (only the name – no registry, no namespace, no tag, no digest).
          Examples: myimage, scanner
        type: string
        required: true
      tag_suffix:
        description: |
          Optional suffix appended to every generated tag.
          If provided, e.g. 'foo' -> 'v1.2.3-foo', 'v1.2-foo', 'v1-foo', 'main-foo', 'latest-foo', ...
        type: string
        default: ""
      mode:
        description: |
          The mode to use:
            BUILD                   - build and publish the image
            CVMFS_BUILD             - BUILD, then request CVMFS to build and persist the image
            CVMFS_REMOVE            - request CVMFS to delete 'inputs.cvmfs_remove_tags'
            CVMFS_REMOVE_THEN_BUILD - CVMFS_REMOVE, then CVMFS_BUILD
        type: string
        required: true
      cvmfs_dest_dir:
        description: |
          IF USING CVMFS (else, var is ignored):
            The CVMFS directory to place the singularity image built from the docker image
          SEE: https://github.com/WIPACrepo/build-singularity-cvmfs-action
        type: string
        required: false
      cvmfs_remove_tags:
        description: |
          IF REMOVING ON CVMFS (else, var is ignored):
            The image **TAGS** (i.e. 'bar' in 'baz/foo:bar') to remove on CVMFS -- newline-delimited
            tags can be a pattern-based or verbatim
          SEE: https://github.com/WIPACrepo/build-singularity-cvmfs-action
          EXAMPLE: '$ {{ github.event.ref }}-[SHA]' (no space after $)
        type: string
        required: false
      free_disk_space:
        description: |
          IF BUILDING VERY LARGE IMAGES (else, var is ignored):
            Whether to free disk space on the GitHub runner before building the image
        type: boolean
        default: false
        required: false
      build_platforms_csv:
        description: |
          IF BUILDING IMAGE (else, var is ignored):
            Comma-delimited list of CPU architecture platforms to build (e.g. linux/amd64,linux/arm64)
        required: false
        type: string
        default: "linux/amd64,linux/arm64"
      build_args:
        description: |
          IF BUILDING IMAGE (else, var is ignored):
            Multiline string of build arguments to pass to the Docker build (format: key=value).
            Each line is one argument.
          EXAMPLE:
            FOO=bar
            BAZ=qux
        required: false
        type: string
        default: ""
      extra_build_tag:
        description: |
          IF BUILDING IMAGE (else, var is ignored):
            If provided, use this tag in addition to the normally automatically generated tags based on GHA trigger event.
          NOTE: this is useful in combination with a manual 'workflow_dispatch' to
            overwrite static tags, ex: 'dev', 'test', 'unstable', etc.
          EXAMPLE: '$ {{ github.event_name == 'workflow_dispatch' && github.event.inputs.my_tag || '' }}' (no space after $)
        required: false
        type: string
        default: ""

    secrets:
      registry_username:
        description: |
          IF USING PUBLISHING TO A CONTAINER REGISTRY (else, var is ignored):
            The username needed for publishing the image to a container registry -- 
            if your registry does not need a username, use `registry_token`. 
          EXAMPLE: use $ {{ secrets.DOCKERHUB_USERNAME }} (no space after $)
        required: false
      registry_token:
        description: |
          IF USING PUBLISHING TO A CONTAINER REGISTRY (else, var is ignored):
            The token/password needed for publishing the image to a container registry.
          EXAMPLE: use $ {{ secrets.DOCKERHUB_TOKEN }} (no space after $)
        required: false
      cvmfs_github_token:
        description: |
          IF USING CVMFS (else, var is ignored):
            A PAT so the workflow can git push to GitHub (used for CVMFS build/removal requests)
          SEE: https://github.com/WIPACrepo/build-singularity-cvmfs-action
        required: false

jobs:
  gameplan:
    # this sets outputs that decide which actions to take in the workflow
    runs-on: ubuntu-latest
    outputs:
      build-platform-matrix: ${{ steps.build-platforms.outputs.matrix }}
      normalized-suffix: ${{ steps.suffix_norm_for_artifacts.outputs.norm }}
    steps:
      - name: Validate image format
        id: validate
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          registry="${{ inputs.image_registry }}"
          namespace="${{ inputs.image_namespace }}"
          image_name="${{ inputs.image_name }}"

          # Registry: alphanum + ._- and optional :port, no slash
          if [[ ! "$registry" =~ ^[a-z0-9._-]+(:[0-9]+)?$ ]]; then
            echo "::error::'registry' contains invalid characters. Found: '$registry'"
            exit 1
          fi

          # Namespace: may contain '/', but no tag/digest
          if [[ "$namespace" == *":"* ]] || [[ "$namespace" == *"@"* ]]; then
            echo "::error::'namespace' must not include a tag or digest. Found: '$namespace'"
            exit 1
          fi

          # Image name: alphanum + ._-, no slash
          if [[ ! "$image_name" =~ ^[a-z0-9._-]+$ ]]; then
            echo "::error::'image_name' contains invalid characters. Found: '$image_name'"
            exit 1
          fi

      - name: "Normalize suffix for use in artifacts"
        id: suffix_norm_for_artifacts
        shell: bash
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          norm="${{ inputs.tag_suffix }}"
          if [[ -z "${norm}" ]]; then norm="nosuffix"; fi
          echo "norm=${norm}" >> "$GITHUB_OUTPUT"

      - name: Prepare build-platform matrix
        id: build-platforms
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          export INPUT_BUILD_PLATFORMS_CSV="${{ inputs.build_platforms_csv }}"

          matrix_json=$(python -c '
          import os, json

          platforms_csv = os.environ.get("INPUT_BUILD_PLATFORMS_CSV", "linux/amd64")
          platforms = [s.strip() for s in platforms_csv.split(",") if s.strip()]

          label_map = {
            "linux/amd64": "ubuntu-latest",
            "linux/arm64": "ubuntu-24.04-arm",
          }

          matrix = [
            {
              "platform": p,
              "runner": label_map.get(p, "ubuntu-latest")
            } 
            for p in platforms
          ]
          print(json.dumps(matrix))
          ')

          echo "matrix<<EOF" >> "$GITHUB_OUTPUT"
          echo "$matrix_json" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Summary (appears in GitHub UI)
        if: always()
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          {
            echo "# 🧭 Workflow Plan — Mode: \`${{ inputs.mode }}\`"
            echo "_By WIPACrepo/wipac-dev-workflows/image-publish/workflow.yml_"
            echo ""
          
            echo "### 🧩 GitHub Context"
            echo "- ref: \`${{ github.ref }}\`"
            echo "- sha: \`${{ github.sha }}\`"
            echo "- ref_type: \`${{ github.ref_type }}\`"
          
            echo "### 🔧 Inputs"
            echo "- \`image\` = ${{ inputs.image_registry }}/${{ inputs.image_namespace }}/${{ inputs.image_name }}"
            echo "- \`mode\` = ${{ inputs.mode }}"
            echo "- \`registry_username\` = ${{ secrets.registry_username || 'null' }}"
            echo "- \`cvmfs_dest_dir\` = ${{ inputs.cvmfs_dest_dir || 'null' }}"
            echo "- \`cvmfs_remove_tags\` ="
            echo '```'
            echo "${{ inputs.cvmfs_remove_tags }}"
            echo '```'
            echo "- \`extra_build_tag\` = ${{ inputs.extra_build_tag || 'null' }}"
            echo "- \`tag_suffix\` = ${{ inputs.tag_suffix != '' && inputs.tag_suffix || 'null' }}"
            echo ""
          
            if [[ "${{ inputs.mode }}" == "BUILD" || \
                  "${{ inputs.mode }}" == "CVMFS_BUILD" || \
                  "${{ inputs.mode }}" == "CVMFS_REMOVE_THEN_BUILD" ]]; then
              echo "### 📋 Build Config"
              echo "- \`platform matrix\` = ${{ steps.build-platforms.outputs.matrix }}"
              echo ""
            fi

            echo "### ⏭️ Planned Actions"
            if [[ "${{ inputs.mode }}" == "CVMFS_REMOVE" || \
                  "${{ inputs.mode }}" == "CVMFS_REMOVE_THEN_BUILD" ]]; then
              echo "- Will request CVMFS image removal"
            fi
            if [[ "${{ inputs.mode }}" == "BUILD" || \
                  "${{ inputs.mode }}" == "CVMFS_BUILD" || \
                  "${{ inputs.mode }}" == "CVMFS_REMOVE_THEN_BUILD" ]]; then
              echo "- Will build & publish Docker image(s)"
            fi
            if [[ "${{ inputs.mode }}" == "CVMFS_BUILD" || \
                  "${{ inputs.mode }}" == "CVMFS_REMOVE_THEN_BUILD" ]]; then
              echo "- Will request CVMFS Singularity build"
            fi

            echo ""

            echo "_Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")_"
          } >> "$GITHUB_STEP_SUMMARY"     

      # ── Early guard: prevent multiple workflow_call invocations from using the same tag_suffix
      - name: "Unique parallel artifacts check: GitHub API"
        id: suffix_guard_check
        uses: actions/github-script@v7
        env:
          GUARD_NAME: suffix-guard-${{ inputs.image_name }}-${{ steps.suffix_norm_for_artifacts.outputs.norm }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const run_id = context.runId;
            const target = process.env.GUARD_NAME;
            const res = await github.rest.actions.listWorkflowRunArtifacts({
              owner, repo, run_id, per_page: 100
            });
            const hit = res.data.artifacts.find(a => a.name === target);
            core.setOutput('exists', hit ? 'true' : 'false');
            if (hit) {
              core.setFailed(
                `Another workflow_call is using the same 'tag_suffix' — make each invocation's 'tag_suffix' unique.`
              );
            }
      - name: "Unique parallel artifacts check: Create guard file"
        if: steps.suffix_guard_check.outputs.exists == 'false'
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          printf "reserved by job=%s at %s\n" "${GITHUB_JOB}" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" > guard.txt
      - name: "Unique parallel artifacts check: Upload guard artifact"
        if: steps.suffix_guard_check.outputs.exists == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: suffix-guard-${{ inputs.image_name }}-${{ steps.suffix_norm_for_artifacts.outputs.norm }}
          path: guard.txt
          retention-days: 1
          overwrite: false


  maybe-remove-from-cvmfs:
    needs: [ gameplan ]
    runs-on: ubuntu-latest
    if: >
      inputs.mode == 'CVMFS_REMOVE' ||
      inputs.mode == 'CVMFS_REMOVE_THEN_BUILD' ||
      inputs.mode == 'CVMFS_BUILD'
    # NOTE: ^^^ job 'build-on-cvmfs' depends on this job -- so, allow job to succeed & use step-ifs
    steps:
      - name: "Skip Job: CVMFS removal not requested (no-op)"
        if: inputs.mode == 'CVMFS_BUILD'
        run: echo "Will NOT remove CVMFS image(s)"

      - name: "Do Job: CVMFS removal requested"
        if: >
          inputs.mode == 'CVMFS_REMOVE' ||
          inputs.mode == 'CVMFS_REMOVE_THEN_BUILD'
        run: echo "Will remove CVMFS image(s)."

      - name: Generate CVMFS image nametags to remove
        if: >
          inputs.mode == 'CVMFS_REMOVE' ||
          inputs.mode == 'CVMFS_REMOVE_THEN_BUILD'
        id: gen
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          
          python -c '
          import os
          tags = """${{ inputs.cvmfs_remove_tags }}"""
          image = "${{ inputs.image_name }}"
          with open("delete_image_nametags.txt", "w") as f:
              for t in tags.splitlines():
                  if t.strip():
                      f.write(f"{image}:{t.strip()}\n")
          '
          
          echo "delete_image_nametags<<EOF" >> "$GITHUB_OUTPUT"
          cat delete_image_nametags.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Request CVMFS removal
        if: >
          inputs.mode == 'CVMFS_REMOVE' ||
          inputs.mode == 'CVMFS_REMOVE_THEN_BUILD'
        uses: WIPACrepo/build-singularity-cvmfs-action@v2.0
        with:
          github_token: ${{ secrets.cvmfs_github_token }}
          dest_dir: ${{ inputs.cvmfs_dest_dir }}
          delete_image_nametags: ${{ steps.gen.outputs.delete_image_nametags }}


  build-w-platform-and-publish-by-sha:
    if: >
      inputs.mode == 'BUILD' ||
      inputs.mode == 'CVMFS_BUILD' ||
      inputs.mode == 'CVMFS_REMOVE_THEN_BUILD'
    needs: [ gameplan ]
    strategy:
      matrix:
        include: ${{ fromJson(needs.gameplan.outputs.build-platform-matrix) }}
    runs-on: ${{ matrix.runner }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
          fetch-depth: 0  # git history + tags -> python's setuptools-scm can get correct version

      # LOG INTO CONTAINER REGISTRY
      - name: Docker login
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.image_registry }}
          username: ${{ inputs.image_registry == 'ghcr.io' && github.actor || secrets.registry_username }}
          password: ${{ inputs.image_registry == 'ghcr.io' && secrets.GITHUB_TOKEN || secrets.registry_token }}

      # VERY BASIC METADATA - tagging occurs in 'tag-and-merge-published-images' (job)
      - id: docker_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.image_registry }}/${{ inputs.image_namespace }}/${{ inputs.image_name }}

      # BUILD STEPS
      - if: inputs.free_disk_space == 'true'
        uses: jlumbroso/free-disk-space@main
        with:
          docker-images: false
      - uses: docker/setup-buildx-action@v3
      - id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          build-args: ${{ inputs.build_args }}
          platforms: ${{ matrix.platform }}
          tags: ${{ inputs.image_registry }}/${{ inputs.image_namespace }}/${{ inputs.image_name }}
          labels: ${{ steps.docker_meta.outputs.labels }}
          outputs: type=image,push-by-digest=true,name-canonical=true,push=true

      # USE ARTIFACTS
      - name: "Store platform-specific image@digest in a file named for the platform"
        id: save_digest
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          mkdir -p "${{ runner.temp }}/to-be-artifacts"

          platform="${{ matrix.platform }}"
          safe_platform="${platform//\//_}"  # replace / with _
          image_at_digest="${{ inputs.image_registry }}/${{ inputs.image_namespace }}/${{ inputs.image_name }}@${{ steps.build.outputs.digest }}"

          set -x
          file="${{ runner.temp }}/to-be-artifacts/${safe_platform}.txt"
          echo "${image_at_digest}" > "$file"
          echo "safe_platform=$safe_platform" >> "$GITHUB_OUTPUT"
          
          cat "$file"

      # === UPLOAD ===
      - uses: actions/upload-artifact@v4
        with:
          name: platform-digests-${{ inputs.image_name }}-${{ needs.gameplan.outputs.normalized-suffix }}-${{ steps.save_digest.outputs.safe_platform }}
          path: ${{ runner.temp }}/to-be-artifacts/*
          if-no-files-found: error
          retention-days: 1


  tag-and-merge-published-images:
    # now, tag the image(s) just published -- if multiple images, this merges under a single manifest
    if: >
      inputs.mode == 'BUILD' ||
      inputs.mode == 'CVMFS_BUILD' ||
      inputs.mode == 'CVMFS_REMOVE_THEN_BUILD'
    needs: [
      gameplan,
      build-w-platform-and-publish-by-sha, # needed b/c image(s) need to be published before tagging/merging
    ]
    runs-on: ubuntu-latest
    outputs:
      tags: ${{ steps.docker_meta.outputs.tags }}
      summary_manifest_ref: ${{ steps.push_manifest.outputs.summary_manifest_ref }}
    steps:
      # TAG-PUSHES ONLY: DETECT THE RELATED BRANCH
      - name: "Tag-Pushes Only: Checkout" # do first, so we don't overwrite any files
        if: github.ref_type == 'tag'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # we need git tags
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
      - name: "Tag-Pushes Only: Resolve branch name, short SHA, and tag kind"
        id: branch_for_tag
        if: github.ref_type == 'tag'
        shell: bash
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          git fetch --all --tags --prune

          ########################################################################
          # Determine branch name(s) containing this commit
          ########################################################################
          branches="$(git for-each-ref --format='%(refname:short)' --contains "${GITHUB_SHA}" refs/remotes/origin/* | sed 's#^origin/##')"

          pick=""
          for b in main master develop dev; do
            if echo "${branches}" | grep -qx "${b}"; then
              pick="${b}"
              break
            fi
          done
          if [[ -z "${pick}" && -n "${branches}" ]]; then
            pick="$(echo "${branches}" | head -n1)"
          fi

          ########################################################################
          # Resolve short SHA for this commit
          ########################################################################
          shortsha="$(git rev-parse --short=7 "$GITHUB_SHA")"

          ########################################################################
          # Classify the git tag
          # - v<digit>… → semver-ish (e.g. v1, v1.2, v1.2.3)
          # - anything else → treated as a raw, non-semver tag
          ########################################################################
          tag_name="${GITHUB_REF_NAME}"
          if [[ "$tag_name" =~ ^v[0-9]+(\.[0-9]+(\.[0-9]+)?)?$ ]]; then
            is_v_semverish=true
          else
            is_v_semverish=false
          fi

          ########################################################################
          # Emit outputs
          ########################################################################
          echo "branch=${pick}"             >> "$GITHUB_OUTPUT"
          echo "shortsha=${shortsha}"       >> "$GITHUB_OUTPUT"
          echo "is_v_semverish=${is_v_semverish}" >> "$GITHUB_OUTPUT"

      # === DOWNLOAD ===
      - uses: actions/download-artifact@v4
        with:
          pattern: platform-digests-${{ inputs.image_name }}-${{ needs.gameplan.outputs.normalized-suffix }}-*
          path: platform-digests
          merge-multiple: true

      # LOG INTO CONTAINER REGISTRY
      - name: Docker login
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.image_registry }}
          username: ${{ inputs.image_registry == 'ghcr.io' && github.actor || secrets.registry_username }}
          password: ${{ inputs.image_registry == 'ghcr.io' && secrets.GITHUB_TOKEN || secrets.registry_token }}

      # GENERATE TAGS
      - id: docker_meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ inputs.image_registry }}/${{ inputs.image_namespace }}/${{ inputs.image_name }}
          tags: |
            # CUSTOM TAG: using 'extra_build_tag'\
            #   example: dev
            type=raw,value=${{ inputs.extra_build_tag }},enable=${{ inputs.extra_build_tag != '' }}
            
            # RUNNING ON: branch
            # -> verbatim branch name
            #   example: main
            #   example: foo
            # NOTE: if the branch is 'main' or 'master', an extra ':latest' tag is also created (default flavor.latest=auto)
            type=ref,event=branch
            # -> SHA suffix
            #   example: main-1a2b3c4
            #   example: foo-4d5e6f7
            type=sha,prefix={{branch}}-,enable=${{ github.ref_type == 'branch' }}
            
            # RUNNING ON: new tag
            # -> semver-derived tags
            #   example: v1 + v1.2 + v1.2.3
            type=semver,pattern={{major}},enable=${{ github.ref_type == 'tag' }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ github.ref_type == 'tag' }}
            type=semver,pattern={{major}}.{{minor}}.{{patch}},enable=${{ github.ref_type == 'tag' }}
            # -> branch-based tags
            #   example: main + main-1a2b3c4
            type=raw,value=${{ steps.branch_for_tag.outputs.branch }},enable=${{ github.ref_type == 'tag' && steps.branch_for_tag.outputs.branch != '' }}
            type=raw,value=${{ steps.branch_for_tag.outputs.branch }}-${{ steps.branch_for_tag.outputs.shortsha }},enable=${{ github.ref_type == 'tag' && steps.branch_for_tag.outputs.shortsha != '' }}
            # -> verbatim git tag (for non-semver tags)
            #   example: oct-20-prerelease, foo, etc.
            type=ref,event=tag,enable=${{ github.ref_type == 'tag' && steps.branch_for_tag.outputs.is_v_semverish != 'true' }}
          flavor: |
            suffix=${{ inputs.tag_suffix }}
            latest=auto

      # APPLY TAGS TO IMAGE(S)
      - uses: docker/setup-buildx-action@v3
      - name: Create and push manifest
        id: push_manifest
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          # platform-specific image digests (sha) from those published in 'build-w-platform-and-publish-by-sha' (job)
          shopt -s nullglob
          echo "debug: listing downloaded digests"
          ls -laR platform-digests || true
          images_w_sha=""
          files=(platform-digests/*.txt)
          if (( ${#files[@]} == 0 )); then
            echo "::error::No platform digest artifacts found in ./platform-digests"
            exit 1
          fi
          for f in "${files[@]}"; do
            ref="$(cat "$f")"
            echo "$ref"  # for logging
            images_w_sha="$images_w_sha $ref"
          done

          # tags made from 'docker_meta' (step) -- from newline-delimited string
          all_tags=""
          readarray -t tag_arr <<< "${{ steps.docker_meta.outputs.tags }}"
          for tag in "${tag_arr[@]}"; do
              all_tags+=" --tag $tag"
          done

          # validate
          if [[ -z "$all_tags" ]]; then
              echo "::error::No tags were generated to apply to the manifest."
              exit 1
          fi

          # go!
          # create a single multi-platform image manifest with all tags pointing to published digests
          docker buildx imagetools create $all_tags $images_w_sha

          # Try to read the merged manifest digest (registry may need a few seconds)
          # (first tag is fine since all tags point to the same manifest)
          first_tag="${tag_arr[0]}"
          digest=""
          echo "reading the merged manifest's digest to show in summary"
          max=10
          for attempt in $(seq 1 "$max"); do
              docker buildx imagetools inspect "$first_tag" || true  # debug, don't fail the step
              digest="$(docker buildx imagetools inspect "$first_tag" 2>/dev/null | awk '/^Digest:/ {print $2; exit}' || true)"
              if [[ -n "$digest" ]]; then
                break
              fi
              n_sleep=$((attempt * 5))
              echo "manifest not yet available on registry -- trying again in ${n_sleep}s"
              sleep "$n_sleep"  # 5s, 10s, 15s, ...
          done
          if [[ -n "$digest" ]]; then
              echo "summary_manifest_ref=${{ inputs.image_registry }}/${{ inputs.image_namespace }}/${{ inputs.image_name }}@$digest" >> "$GITHUB_OUTPUT"
          else
              fallback="unknown — not available at time of workflow end"
              echo "::warning::Could not inspect merged manifest for $first_tag — summary will show '$fallback'"
              echo "summary_manifest_ref=$fallback" >> "$GITHUB_OUTPUT"
          fi


  build-on-cvmfs:
    if: >
      inputs.mode == 'CVMFS_BUILD' ||
      inputs.mode == 'CVMFS_REMOVE_THEN_BUILD'
    needs: [
      gameplan,
      maybe-remove-from-cvmfs,  # needed b/c cvmfs removals need to happen before builds
      tag-and-merge-published-images,  # needed for retrieving images
    ]
    runs-on: ubuntu-latest
    steps:
      - name: Select single best image tag for CVMFS build
        id: select
        env:
          TAGS: ${{ needs.tag-and-merge-published-images.outputs.tags }}
          TAG_SUFFIX: ${{ inputs.tag_suffix }}
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          pick="$(python -c "
          import re
          import sys
          import os

          # Read newline-delimited refs from env (robust against quoting)
          tags = [t.strip() for t in os.environ['TAGS'].splitlines() if t.strip()]
          suffix = os.environ.get('TAG_SUFFIX', '').lstrip('-')
          
          def tag_part(ref: str) -> str:
              return ref.rsplit(':', 1)[-1]
          
          # Exclude 'latest' and 'latest-<suffix>'
          filtered = []
          for r in tags:
            t = tag_part(r)
            if t == 'latest' or (suffix and t == f'latest-{suffix}'):
              continue
            filtered.append(r)
          
          def first_match(rx_list: list[str]):
            for rx in rx_list:
              pat = re.compile(rx)
              for ref in filtered:
                if pat.fullmatch(tag_part(ref)):
                  return ref
            return None
          
          # Base regexes (no suffix)
          regexes = [
            r'^[vV]?\d+\.\d+\.\d+$',   # v1.2.3
            r'^.+-[0-9a-f]{7}$',       # new-feature-abcdef0
            r'^[vV]?\d+\.\d+$',        # v1.2
            r'^[vV]?\d+$',             # v1
          ]
          # -- if suffix provided, append suffixed variants
          if suffix:
            _suf = re.escape(suffix)
            for base in list(regexes):
              regexes.append(base.rstrip('$') + f'-{_suf}$')
          
          # Choose best tag
          pick = first_match(regexes)
          if not pick:
            print('::error::Could not select a tag from generated list:', file=sys.stderr)
            for t in tags:
              print(t, file=sys.stderr)
            sys.exit(1)
          else:
            print(pick)
          ")"
          
          echo "Selected for CVMFS: ${pick}"
          echo "tag=${pick}" >> "$GITHUB_OUTPUT"

      - uses: WIPACrepo/build-singularity-cvmfs-action@v2.0
        with:
          github_token: ${{ secrets.cvmfs_github_token }}
          dest_dir: ${{ inputs.cvmfs_dest_dir }}
          build_images: ${{ steps.select.outputs.tag }}


  final-summary:
    if: always()
    needs: [
      # after all jobs:
      gameplan,
      maybe-remove-from-cvmfs,
      build-w-platform-and-publish-by-sha,
      tag-and-merge-published-images,
      build-on-cvmfs,
    ]
    runs-on: ubuntu-latest
    steps:
      - name: Download platform digests
        if: >
          inputs.mode == 'BUILD' ||
          inputs.mode == 'CVMFS_BUILD' ||
          inputs.mode == 'CVMFS_REMOVE_THEN_BUILD'
        uses: actions/download-artifact@v4
        with:
          pattern: platform-digests-${{ inputs.image_name }}-${{ needs.gameplan.outputs.normalized-suffix }}-*
          path: platform-digests
          merge-multiple: true

      - name: Generate Final Summary (appears in GitHub UI)
        if: always()
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          {
            echo "# ✅ Final Workflow Summary — Mode: \`${{ inputs.mode }}\`"
            echo "_By WIPACrepo/wipac-dev-workflows/image-publish/workflow.yml_"
            echo ""
            echo "## 📦 Image: \`${{ inputs.image_registry }}/${{ inputs.image_namespace }}/${{ inputs.image_name }}\`"
            echo ""

            if [[ "${{ inputs.mode }}" == "BUILD" || "${{ inputs.mode }}" == "CVMFS_BUILD" || "${{ inputs.mode }}" == "CVMFS_REMOVE_THEN_BUILD" ]]; then

              echo "## 🔢 Tags Published"
              echo '```'
              echo "${{ needs.tag-and-merge-published-images.outputs.tags }}"
              echo '```'
              echo ""

              echo "## 🔗 Image Reference"
              echo '```'
              echo "${{ needs.tag-and-merge-published-images.outputs.summary_manifest_ref }}"
              echo '```'
              echo ""

              echo "### 🖥️ Per-Platform Builds"
              echo "<details><summary>Show details</summary>"
              echo
              shopt -s nullglob
              files=(platform-digests/*.txt)
              echo '```'
              for f in "${files[@]}"; do
                ref=$(cat "$f")
                platform=$(basename "$f" .txt | tr '_' '/')
                echo "$platform → $ref"
              done
              echo '```'
              shopt -u nullglob
              echo "</details>"
              echo ""

            fi

            if [[ "${{ inputs.mode }}" == "CVMFS_BUILD" || "${{ inputs.mode }}" == "CVMFS_REMOVE" || "${{ inputs.mode }}" == "CVMFS_REMOVE_THEN_BUILD" ]]; then
              echo "## 📁 CVMFS"
              echo "See [docker_images.txt](https://github.com/WIPACrepo/cvmfs-actions/blob/main/docker_images.txt)"
              echo ""
            fi

            echo "_Summary generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")_"
          } >> "$GITHUB_STEP_SUMMARY"
