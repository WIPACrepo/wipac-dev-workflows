name: Build/Publish Docker Images and, optionally, Singularity Images on CVMFS


on:
  workflow_dispatch:
    inputs:
      image:
        description: |
          The full-qualified image (tagless) --
            include a registry if not storing with dockerhub
          EXAMPLE: 'ghcr.io/foo/bar', 'foo/bar', etc.
        required: true
      mode:
        description: |
          The mode to use:
            BUILD                   - build and publish 'inputs.image'
            CVMFS_BUILD             - BUILD, then request CVMFS to build and persist 'inputs.image'
            CVMFS_REMOVE            - request CVMFS to delete 'inputs.cvmfs_remove_images'
            CVMFS_REMOVE_THEN_BUILD - CVMFS_REMOVE, then CVMFS_BUILD
        required: true
      registry_username:
        description: |
          IF USING PUBLISHING TO A CONTAINER REGISTRY (else, var is ignored):
            The username needed for publishing the image to a container registry -- 
            if your registry does not need a username, use `registry_token`. 
          EXAMPLE: use $ {{ secrets.DOCKERHUB_USERNAME }} (no space after $)
        required: false
      registry_token:
        description: |
          IF USING PUBLISHING TO A CONTAINER REGISTRY (else, var is ignored):
            The token/password needed for publishing the image to a container registry.
          EXAMPLE: use $ {{ secrets.DOCKERHUB_TOKEN }} (no space after $)
          EXAMPLE: use $ {{ secrets.GITHUB_TOKEN }} (no space after $)
        required: false
      cvmfs_github_token:
        description: |
          IF USING CVMFS (else, var is ignored):
            A PAT so the workflow can git push to GitHub (used for CVMFS build/removal requests)
          SEE: https://github.com/WIPACrepo/build-singularity-cvmfs-action
        required: false
      cvmfs_dest_dir:
        description: |
          IF USING CVMFS (else, var is ignored):
            The CVMFS directory to place the singularity image built from the docker image
          SEE: https://github.com/WIPACrepo/build-singularity-cvmfs-action
        required: false
      cvmfs_remove_tags:
        description: |
          IF REMOVING ON CVMFS (else, var is ignored):
            The image **TAGS** (i.e. 'bar' in 'baz/foo:bar') to remove on CVMFS -- newline-delimited
            tags can be a pattern-based or verbatim
          SEE: https://github.com/WIPACrepo/build-singularity-cvmfs-action
          EXAMPLE: '$ {{ github.ref_name }}-[SHA]' (no space after $)
        required: false
      free_disk_space:
        description: |
          IF BUILDING VERY LARGE IMAGES (else, var is ignored):
            Whether to free disk space on the GitHub runner before building the image
        required: false
        default: "false"
      build_platforms_csv:
        description: |
          IF BUILDING IMAGE (else, var is ignored):
            Comma-delimited list of CPU architecture platforms to build (e.g. linux/amd64,linux/arm64)
        required: false
        default: "linux/amd64,linux/arm64"


jobs:
  determine-plan:
    runs-on: ubuntu-latest
    outputs:
      do-remove-from-cvmfs: ${{ steps.set.outputs.do-remove-from-cvmfs }}
      do-build-and-publish-image: ${{ steps.set.outputs.do-build-and-publish-image }}
      do-build-on-cvmfs: ${{ steps.set.outputs.do-build-on-cvmfs }}
      image-name: ${{ steps.validate.outputs.image-name }}
      build-platform-matrix: ${{ steps.build-platforms.outputs.matrix }}
    steps:
      - name: Determine workflow plan
        id: set
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          echo "do-remove-from-cvmfs=false" >> "$GITHUB_OUTPUT"
          echo "do-build-and-publish-image=false" >> "$GITHUB_OUTPUT"
          echo "do-build-on-cvmfs=false" >> "$GITHUB_OUTPUT"

          case "${{ inputs.mode }}" in
            CVMFS_REMOVE)
              echo "do-remove-from-cvmfs=true" >> "$GITHUB_OUTPUT"
              ;;
            BUILD)
              echo "do-build-and-publish-image=true" >> "$GITHUB_OUTPUT"
              ;;
            CVMFS_BUILD)
              echo "do-build-and-publish-image=true" >> "$GITHUB_OUTPUT"
              echo "do-build-on-cvmfs=true" >> "$GITHUB_OUTPUT"
              ;;
            CVMFS_REMOVE_THEN_BUILD)
              echo "do-remove-from-cvmfs=true" >> "$GITHUB_OUTPUT"
              echo "do-build-and-publish-image=true" >> "$GITHUB_OUTPUT"
              echo "do-build-on-cvmfs=true" >> "$GITHUB_OUTPUT"
              ;;
            *)
              echo "::error::Unrecognized mode: '${{ inputs.mode }}'"
              exit 1
              ;;
          esac

      - name: Validate image format
        id: validate
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          last_segment=$(basename "${{ inputs.image }}")
          if [[ "$last_segment" == *:* || "$last_segment" == *@* ]]; then
            echo "::error::'image' must not include a tag or digest"
            exit 1
          fi

          echo "image-name=$last_segment" >> "$GITHUB_OUTPUT"

      - name: Prepare build-platform matrix
        id: build-platforms
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          
          export INPUT_BUILD_PLATFORMS_CSV="${{ inputs.build_platforms_csv }}"
          
          matrix_json=$(python -c '
          import os, json
          
          platforms_csv = os.environ.get("INPUT_BUILD_PLATFORMS_CSV", "linux/amd64")
          platforms = [s.strip() for s in platforms_csv.split(",") if s.strip()]
          
          label_map = {
            "linux/amd64": "ubuntu-latest",
            "linux/arm64": "ubuntu-24.04-arm",
          }
          
          matrix = [
            {
              "platform": p,
              "runner": label_map.get(p, "ubuntu-latest")
            } 
            for p in platforms
          ]
          print(f"matrix={json.dumps(matrix)}")
          ')
          
          echo "matrix=${matrix_json}" >> "$GITHUB_OUTPUT"


  remove-from-cvmfs:
    if: needs.determine-plan.outputs.do-remove-from-cvmfs == 'true'
    needs: [ determine-plan ]
    runs-on: ubuntu-latest
    steps:
      - name: Generate CVMFS image nametags to remove
        id: gen
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          
          python -c '
          import os
          tags = """${{ inputs.cvmfs_remove_tags }}"""
          image = "${{ needs.determine-plan.outputs.image-name }}"
          print("\\n".join(f"{image}:{t.strip()}" for t in tags.splitlines() if t.strip()))
          ' > delete_image_nametags.txt
          
          echo "delete_image_nametags<<EOF" >> "$GITHUB_OUTPUT"
          cat delete_image_nametags.txt >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Request CVMFS removal
        uses: WIPACrepo/build-singularity-cvmfs-action@v2.0
        with:
          github_token: ${{ inputs.cvmfs_github_token }}
          dest_dir: ${{ inputs.cvmfs_dest_dir }}
          delete_image_nametags: ${{ steps.gen.outputs.delete_image_nametags }}


  build-w-platform-and-publish-by-sha:
    if: needs.determine-plan.outputs.do-build-and-publish-image == 'true'
    needs: [ determine-plan ]
    strategy:
      matrix:
        include: ${{ fromJson(needs.determine-plan.outputs.build-platform-matrix) }}
    runs-on: ${{ matrix.runner }}
    name: Build+publish image (${{ matrix.platform }})
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
      - uses: docker/login-action@v3
        with:
          registry: ${{ ( startsWith(inputs.image, 'ghcr.io/') && 'ghcr.io' ) || '' }}
          username: ${{ inputs.registry_username }}
          password: ${{ inputs.registry_token }}

      # VERY BASIC METADATA - tagging occurs in 'tag-published-images' (job)
      - id: docker_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.image }}

      # BUILD STEPS
      - if: inputs.free_disk_space == 'true'
        uses: jlumbroso/free-disk-space@main
        with:
          docker-images: false
      - if: contains(matrix.platform, 'arm')
        uses: docker/setup-qemu-action@v2
      - uses: docker/setup-buildx-action@v2
      - id: build
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: ${{ matrix.platform }}
          tags: ${{ inputs.image }}
          labels: ${{ steps.docker_meta.outputs.labels }}
          outputs: type=image,push-by-digest=true,name-canonical=true,push=true

      # USE ARTIFACTS
      - name: Store digest (sha) as artifact -- in a file named for the build platform
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          mkdir -p ${{ runner.temp }}/digests
          echo "${{ steps.build.outputs.digest }}" \
            > "${{ runner.temp }}/digests/${{ matrix.platform //\//_ }}.txt"
      - uses: actions/upload-artifact@v4
        with:
          name: digests
          path: ${{ runner.temp }}/digests/*
          if-no-files-found: error
          retention-days: 1


  tag-published-images: # now, tag the image(s) just published -- this merges under a single manifest (if multiple images)
    if: needs.determine-plan.outputs.do-build-and-publish-image == 'true'
    needs: [
      determine-plan,
      build-w-platform-and-publish-by-sha, # needed b/c image(s) need to be published before tagging/merging
    ]
    runs-on: ubuntu-latest
    outputs:
      tags: ${{ steps.docker_meta.outputs.tags }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: digests
          path: digests
      - uses: docker/login-action@v3
        with:
          registry: ${{ ( startsWith(inputs.image, 'ghcr.io/') && 'ghcr.io' ) || '' }}
          username: ${{ inputs.registry_username }}
          password: ${{ inputs.registry_token }}

      # GENERATE TAGS
      - id: docker_meta
        uses: docker/metadata-action@v4
        with:
          images: |
            ${{ inputs.image }}
          tags: |
            # running on: branch
            type=sha,prefix={{branch}}-,enable=${{ github.ref_type == 'branch' }}
            # running on: new tag
            type=semver,pattern={{major}},enable=${{ github.ref_type == 'tag' }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ github.ref_type == 'tag' }}
            type=semver,pattern={{major}}.{{minor}}.{{patch}},enable=${{ github.ref_type == 'tag' }}

      # APPLY TAGS TO IMAGE(S)
      - uses: docker/setup-buildx-action@v3
      - name: Create and push manifest
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"

          # images (w/ sha) from those published in 'build-w-platform-and-publish-by-sha' (job)
          sha_images=""
          for f in digests/*.txt; do
            digest=$(cat "$f")
            echo "$digest"  # for logging
            sha_images="$sha_images ${{ inputs.image }}@$digest"
          done
          
          # tags made from 'docker_meta' (step) -- from newline-delimited string
          all_tags=""
          readarray -t tag_arr <<< "${{ steps.docker_meta.outputs.tags }}"
          for tag in "${tag_arr[@]}"; do
              all_tags+=" --tag $tag"
          done
          
          # validate
          if [[ -z "$all_tags" ]]; then
              echo "::error::No tags were generated to apply to the manifest."
              exit 1
          fi

          # go!
          docker buildx imagetools create $all_tags $sha_images


  build-on-cvmfs:
    if: needs.determine-plan.outputs.do-build-on-cvmfs == 'true'
    needs: [
      determine-plan,
      remove-from-cvmfs,  # needed b/c cvmfs removals need to happen before builds
      tag-published-images,  # needed for retrieving images
    ]
    runs-on: ubuntu-latest
    steps:
      - uses: WIPACrepo/build-singularity-cvmfs-action@v2.0
        with:
          github_token: ${{ inputs.cvmfs_github_token }}
          dest_dir: ${{ inputs.cvmfs_dest_dir }}
          build_images: ${{ needs.tag-published-images.outputs.tags }}
